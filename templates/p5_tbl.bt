//------------------------------------------------
//--- 010 Editor v8.0 Binary Template
//
//      File: AtlusTable_P5.bt
//   Authors: TGE, Lillian Goulston, Scarltz
//   Version: 1.5
//   Purpose: Parse Persona 5 Table files.
//  Category: Persona 5
// File Mask: *.tbl, *.pac
//  ID Bytes: 
//   History: 
//   1.0 - Initial release
//   1.1 - Parse tables from within table.pac, add enums for battle skills and units, misc changes
//   1.2 - Added struct for party member Persona skill list and stat gains, fixed enum for party member IDs
//   1.3 - Added struct and enum for elemental affinities in UNIT.TBL
//   1.4 - Added a lot of new enums for skill data
//       - Added and completed struct for first segment of SKILL.TBL
//       - Added incomplete struct for second segment of SKILL.TBL, most of the fundamental stuff is there, but it's still very much a WIP
//       - Added struct for XP per level in PLAYER.TBL
//       - Started work on AICALC structs
//  1.5 - Added names and comments to most structs for more accessibility and ease of use
//      - Added enums for battle music in ENCOUNTER.TBL
//      - Added enums for Arcana
//------------------------------------------------

//---------------------------------------------
// Includes
//---------------------------------------------
#include "p5_enums.bt"

//---------------------------------------------
// Type definition
//---------------------------------------------
typedef ubyte u8;
typedef ushort u16;
typedef uint u32;

typedef struct
{
    u8 bit0 : 1;
    u8 bit1 : 1;
    u8 bit2 : 1;
    u8 bit3 : 1;
    u8 bit4 : 1;
    u8 bit5 : 1;
    u8 bit6 : 1;
    u8 bit7 : 1;
} b8;

typedef struct
{
    u8 bit0 : 1;
    u8 bit1 : 1;
    u8 bit2 : 1;
    u8 bit3 : 1;
    u8 bit4 : 1;
    u8 bit5 : 1;
    u8 bit6 : 1;
    u8 bit7 : 1;
    u8 bit8 : 1;
    u8 bit9 : 1;
    u8 bit10 : 1;
    u8 bit11 : 1;
    u8 bit12 : 1;
    u8 bit13 : 1;
    u8 bit14 : 1;
    u8 bit15 : 1;
} b16;

typedef struct
{
    u8 bit0 : 1;
    u8 bit1 : 1;
    u8 bit2 : 1;
    u8 bit3 : 1;
    u8 bit4 : 1;
    u8 bit5 : 1;
    u8 bit6 : 1;
    u8 bit7 : 1;
    u8 bit8 : 1;
    u8 bit9 : 1;
    u8 bit10 : 1;
    u8 bit11 : 1;
    u8 bit12 : 1;
    u8 bit13 : 1;
    u8 bit14 : 1;
    u8 bit15 : 1;
    u8 bit16 : 1;
    u8 bit17 : 1;
    u8 bit18 : 1;
    u8 bit19 : 1;
    u8 bit20 : 1;
    u8 bit21 : 1;
    u8 bit22 : 1;
    u8 bit23 : 1;
    u8 bit24 : 1;
    u8 bit25 : 1;
    u8 bit26 : 1;
    u8 bit27 : 1;
    u8 bit28 : 1;
    u8 bit29 : 1;
    u8 bit30 : 1;
    u8 bit31 : 1;
} b32;

//---------------------------------------------
// Helper functions
//---------------------------------------------
local uint __RandomSeed = 0xDEADBABE;
local uint __RandomBit = 0;
local uint __RandomCount = 0;
 
uint MyRandom( uint to )
{
    ++__RandomCount;
    __RandomBit  = ( (__RandomSeed >> 0 ) ^ ( __RandomSeed >> 2 ) ^ ( __RandomSeed >> 3 ) ^ ( __RandomSeed >> 5 ) ) & 1;
    __RandomSeed = ( ( ( ( __RandomBit << 15 ) | ( __RandomSeed >> 1 ) ) + ( 0xBABE / __RandomCount ) ) % to );

    while( __RandomSeed < 0 )
        __RandomSeed += to;

    return __RandomSeed;
}

void DetectEndianness()
{
    // Test endianness
    LittleEndian();
    local uint sizeTest = ReadUInt();
    if ( sizeTest & 0xFF000000 )
        BigEndian();
}

u32 Align( u32 value, u32 alignment )
{
	return (value + (alignment - 1)) & ~(alignment - 1);
}

void FAlign( u32 alignment )
{
	FSeek( Align( FTell(), alignment ) );
}

//---------------------------------------------
// Define structures
//---------------------------------------------

// Persona
typedef struct
{
    b16 Flags1;
    ArcanaID Arcana <name = "Arcana">;
    u8 Level <name = "Level">;
    u8 Strength <name = "Strength">;
    u8 Magic <name = "Magic">;
    u8 Endurance <name = "Endurance">;
    u8 Agility <name = "Agility">;
    u8 Luck <name = "Luck">;
    u8 Unused;
    b16 Flags2;
    u16 Unknown;
} TPersonaStats <name = "Persona Stats">;

local u32 personaSkillSetIndex = 0;
typedef struct
{
    u8 Strength <name = "Strength">;
    u8 Magic <name = "Magic">;
    u8 Endurance <name = "Endurance">;
    u8 Agility <name = "Agility">;
    u8 Luck <name = "Luck">;
    u8 Unused <name = "Unused">;

    struct
    {        
        u8 PendingLevels <name = "Pending Levels">;
        SkillEnabled Enabled <name = "Enabled">; 
        BattleSkill Skill  <name = "Skill">;  
    } PersonaSkill[ 16 ] <name = "Persona Skills">;

} TPersonaSkillSet <name = "Persona Skillset">;

typedef struct
{
    u32 Thresholds[ 98 ] <name = "EXP Threshold">;
} TPersonaLevelUpThresholds <name = "Party Member Level Up Thresholds", comment = "Total XP required to hit each level for each party member">;

typedef struct
{
    u8 Unknown;
    PartyMember Member <name = "Member">;
    u8 LevelsAvailable <name = "Levels Available", comment = "Seems to be the number of level-ups available for stat gains, always set to 99">;
    u8 Unknown;

    struct
    {
        u8 Level <name = "Level">;
        SkillEnabled Enabled <name = "Enabled", comment = "If set to 0, the skill will not be learned, even if it is defined">;
        BattleSkill Skill <name = "Skill">;
    } PersonaSkill[ 32 ] <name = "Persona Skills">;

    struct
    {
        u8 Strength <name = "Strength">;
        u8 Magic <name = "Magic">;
        u8 Endurance <name = "Endurance">;
        u8 Agility <name = "Agility">;
        u8 Luck <name = "Luck">;
    } PersonaStatGain[ 98 ] <name = "Persona Stat Gain by Level">;

} TPersonaPartyMembers <name = "Party Members">;

// Player

typedef struct
{
    u32 XPThreshold;
} TPlayer_LevelUpThresholds;

// Elsai
typedef struct
{
    u16 Unused;
    u16 AiId <name = "AI ID", comment = "All I know about this value is that if it's not 0, it causes the game to load an AI script for this enemy">; 
    u32 Unknown[ 10 ];
} TElsaiSegment1Entry;

typedef struct
{
    u8 Data[ 320 ];
} TElsaiSegment2Entry;

// AICalc tables
// Segment1 probably has bigger chunks than u32
typedef struct
{
    u32 Unknown;
} TAICalc_Segment1;

typedef struct
{
    u32 Unknown;
} TAICalc_Segment2;

typedef struct
{
    u32 Unknown;
} TAICalc_Segment3;

typedef struct
{
    u32 Unknown;
} TAICalc_Segment4;

typedef struct
{
    u32 Unknown;
} TAICalc_Segment5;

typedef struct
{
    u8 Unknown;
    u8 Unknown;
    u8 Unknown;
} TAICalc_Segment6;

typedef struct
{
    u32 Unknown;
} TAICalc_Segment7;

// Encounter
typedef struct
{
    b32 Flags <name = "Flags">;
    u16 Field04;
    u16 Field06;
    BattleUnit Units[ 5 ] <name = "Battle Units">;
    u16 FieldId <name = "Field ID">;
    u16 RoomId <name = "Room ID">;
    MusicID MusicId <name = "Music">;
} TEncounter <name = "Enemy Encounters">;

// Unit table
typedef struct
{
    b16 Flags <name = "Flags">;
    ArcanaID Arcana <name = "Arcana">;
    u8 Unknown1[ 2 ];
    u8 Level <name = "Level">;
    u8 Unknown2[ 2 ];
    u32 Hp <name = "HP">;
    u32 Sp <name = "SP">;
    u8 Strength <name = "Strength">;
    u8 Magic <name = "Magic">;
    u8 Endurance <name = "Endurance">;
    u8 Agility <name = "Agility">;
    u8 Luck <name = "Luck">;
    u8 Unknown3;
    BattleSkill SkillIds[ 8 ] <name = "Battle Skills">;
    u16 ExpReward <name = "EXP Reward">;
    u16 MoneyReward <name = "Money Reward">;
    u16 Unknown4;
    u16 Unknown5;
    u8 Unknown6[ 18 ];
    b16 Unknown7;
    u16 AttackDamage <name = "Attack Damage">;
} TUnitStats <name = "Unit Stats">;

// Still testing whether the last 8 are what I think they are
typedef struct
{
    AffinityStatus PhysAffinity <name = "Physical">;
    AffinityStatus GunAffinity <name = "Gun">;
    AffinityStatus FireAffinity <name = "Fire">;
    AffinityStatus IceAffinity <name = "Ice">;
    AffinityStatus ElecAffinity <name = "Electric">;
    AffinityStatus WindAffinity <name = "Wind">;
    AffinityStatus PsyAffinity <name = "Psy">;
    AffinityStatus NukeAffinity <name = "Nuke">;
    AffinityStatus BlessAffinity <name = "Bless">;
    AffinityStatus CurseAffinity <name = "Curse">;
    AffinityStatus AlmightyAffinity <name = "Almighty">;
    AffinityStatus DizzyAffinity <name = "Dizzy">;
    AffinityStatus ConfuseAffinity <name = "Confuse">;
    AffinityStatus FearAffinity <name = "Fear">;
    AffinityStatus ForgetAffinity <name = "Forget">;
    AffinityStatus HungerAffinity <name = "Physical">;
    AffinityStatus SleepAffinity <name = "Hunger">;
    AffinityStatus RageAffinity <name = "Rage">;
    AffinityStatus DespairAffinity <name = "Despair">;
    AffinityStatus BrainwashAffinity <name = "Brainwash">; 
} TUnitElementalAffinities <name = "Elemental Affinities">;

typedef struct
{
    u32 Values[ 10 ];
    //u16 Values[ 20 ]; // uncomment this if you want them to be shorts
} TUnitSegment2Entry;

typedef struct
{
    u32 Values[ 6 ];
    //u16 Values[ 12 ]; // uncomment this if you want them to be shorts
} TUnitSegment3Entry;

typedef struct
{
    u16 ShadowIndex <name = "Shadow Index">;
    u16 ModelIndex <name = "Model Index">;
} TUnitVisualIndex <name = "Visual Index">;


// Skill
typedef struct
{
    ElementalType Element <name = "Elemental Type">;
    Skill_PassiveOrActive PassiveOrActive <name = "Passive or Active?", comment = "Must be set correctly for the element icon to appear properly, even though it's otherwise redundant">;
    b8 RedundantBitfield_ThanksATLUS <name = "Redundant Bitfield (Thanks, ATLUS)", comment = "Rightmost 4 bits of the bitfield don't do anything. Probably leftovers from early P5 coding.">;
} TSkill_Elements <name = "Skill Elements">;

typedef struct
{
    Skill_CasterEffect1 CasterEffect1 <name = "Caster Effect", comment = "Needs more testing">;
    Skill_CasterEffect2 CasterEffect2 <name = "Caster Effect", comment = "Needs more testing">;
    u8 Unknown <name = "Unknown">;
    Skill_DamageStat DamageStat <name = "Damage Stat", comment = "Determines which stat is used to determine damage">; // does not change whether a skill is physical or magic, that's baked into the element
    Skill_CostType CostType <name = "Cost Type">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
    u8 SkillCost <name = "Skill Cost", comment = "% of max HP or fixed amount of SP">; 
    u8 Unknown <name = "Unknown">;
    Skill_PhysicalOrMagicSkill PhysicalOrMagic <name = "Physical or Magic?", comment = "determines what's affected by either Charge or Concentrate, but doesn't seem to change what's reflected by Tetrakarn or Makarakarn... needs more testing">;
    Skill_NumberOfTargets NumberOfTargets <name = "Number of Targets">;
    Skill_ValidTargets ValidTargets <name = "Valid Targets">;
    Skill_TargetRestrictions TargetRestrictions <name = "Additional Target Restrictions">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
    u8 Accuracy <name = "Accuracy">;
    u8 MinHits <name = "Minimum Number of Hits", comment = "For multi-hit moves">;
    u8 MaxHits <name = "Maximum Number of Hits", comment = "For multi-hit moves">;
    Skill_HPEffect HPEffect <name = "Damage/Healing Type">;
    u16 BaseDamage <name = "Base Damage">;
    Skill_SPEffect SPEffect <name = "Deplete or Restore SP?">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
    u8 SPAmount <name = "SP Amount">;
    Skill_ApplyOrCureEffect ApplyOrCureEffect <name = "Apply or Cure Effect?">;
    u8 SecondaryEffectChance <name = "Effect Chance">;
    u8 Unknown <name = "Unknown">;
    Skill_ApplyEffect0 Effect <name = "Effect">;
    Skill_ApplyEffect1 Effect <name = "Effect">;
    Skill_ApplyEffect2 Effect <name = "Effect">;
    Skill_ApplyEffect3 Effect <name = "Effect">;
    Skill_ApplyEffect4 Effect <name = "Effect">;
    Skill_ApplyEffect5 Effect <name = "Effect">;
    Skill_ApplyBuffDebuff BuffDebuff <name = "Buff/Debuff">;
    Skill_ApplyEffect6 Effect <name = "Effect">;
    u8 CritChance <name = "Crit Chance", comment = "Only works for Physical or Gun skills">;
    u8 Unknown <name = "Unknown">;
    u8 Unknown <name = "Unknown">;
} TSkill_ActiveSkillData <name="Active Skill Data: ">;


//---------------------------------------------
// Parse file structure
//---------------------------------------------
enum TableSegmentType
{
    TableSegmentType_Unknown,
    TableSegmentType_Persona_Stats,
    TableSegmentType_Persona_SkillSets,
    TableSegmentType_Persona_LevelUpThresholds,
    TableSegmentType_Persona_PartyMembers,
    TableSegmentType_Player_LevelUpThresholds,
    TableSegmentType_Elsai_Segment0,
    TableSegmentType_Elsai_Segment1,
    TableSegmentType_AICalc_Segment1,
    TableSegmentType_AICalc_Segment2,
    TableSegmentType_AICalc_Segment3,
    TableSegmentType_AICalc_Segment4,
    TableSegmentType_AICalc_Segment5,
    TableSegmentType_AICalc_Segment6,
    TableSegmentType_AICalc_Segment7,
    TableSegmentType_Encounter,
    TableSegmentType_Skill_Elements,
    TableSegmentType_Skill_ActiveSkillData,
    TableSegmentType_Unit_Stats,
    TableSegmentType_Unit_Segment1,
    TableSegmentType_Unit_ElementalAffinities,
    TableSegmentType_Unit_Segment3,
    TableSegmentType_Unit_VisualIndex,
};

typedef struct( TableSegmentType _type )
{
    uint Size;
    local TableSegmentType type = _type; // for debugging

    switch ( type )
    {
        case TableSegmentType_Persona_Stats:
            TPersonaStats Stats[ Size / sizeof( TPersonaStats ) ];
            break;

        case TableSegmentType_Persona_SkillSets:
            TPersonaSkillSet SkillSets[ Size / sizeof( TPersonaSkillSet ) ];
            break;

        case TableSegmentType_Persona_LevelUpThresholds:
            TPersonaLevelUpThresholds LevelUpThresholds[ Size / sizeof( TPersonaLevelUpThresholds ) ];
            break;

        case TableSegmentType_Persona_PartyMembers:
            TPersonaPartyMembers PartyMembers[ Size / sizeof( TPersonaPartyMembers ) ];
            break;

        case TableSegmentType_Player_LevelUpThresholds:
            TPlayer_LevelUpThresholds LevelUpThresholds[ Size / sizeof( TPlayer_LevelUpThresholds ) ];
            break;

        case TableSegmentType_Elsai_Segment0:
            TElsaiSegment1Entry Entries[ Size / sizeof( TElsaiSegment1Entry ) ];
            break;

        case TableSegmentType_Elsai_Segment1:
            TElsaiSegment2Entry Entries[ Size / sizeof( TElsaiSegment2Entry ) ];
            break;

        case TableSegmentType_AICalc_Segment1:
            TAICalc_Segment1 Entries[ Size / sizeof( TAICalc_Segment1 ) ];
            break;

        case TableSegmentType_AICalc_Segment2:
            TAICalc_Segment2 Entries[ Size / sizeof( TAICalc_Segment2 ) ];
            break;

        case TableSegmentType_AICalc_Segment3:
            TAICalc_Segment3 Entries[ Size / sizeof( TAICalc_Segment3 ) ];
            break;

        case TableSegmentType_AICalc_Segment4:
            TAICalc_Segment4 Entries[ Size / sizeof( TAICalc_Segment4 ) ];
            break;

        case TableSegmentType_AICalc_Segment5:
            TAICalc_Segment5 Entries[ Size / sizeof( TAICalc_Segment5 ) ];
            break;

        case TableSegmentType_AICalc_Segment6:
            TAICalc_Segment6 Entries[ Size / sizeof( TAICalc_Segment6 ) ];
            break;

        case TableSegmentType_AICalc_Segment7:
            TAICalc_Segment7 Entries[ Size / sizeof( TAICalc_Segment7 ) ];
            break;

        case TableSegmentType_Encounter:
            TEncounter TEncounters[ Size / sizeof( TEncounter ) ];
            break;

        case TableSegmentType_Skill_Elements:
            TSkill_Elements Skill[ Size / sizeof( TSkill_Elements ) ];
            break;

        case TableSegmentType_Skill_ActiveSkillData:
            TSkill_ActiveSkillData Skill[ Size / sizeof( TSkill_ActiveSkillData ) ];
            break;

        case TableSegmentType_Unit_Stats:
            TUnitStats Stats[ Size / sizeof( TUnitStats ) ];
            break;

        case TableSegmentType_Unit_Segment1:
            TUnitSegment2Entry Entries[ Size / sizeof( TUnitSegment2Entry ) ];
            break;

        case TableSegmentType_Unit_ElementalAffinities:
            TUnitElementalAffinities ElementalAffinities[ Size / sizeof( TUnitElementalAffinities ) ];
            break;

        case TableSegmentType_Unit_Segment3:
            TUnitSegment3Entry Entries[ Size / sizeof( TUnitSegment3Entry ) ];
            break;

        case TableSegmentType_Unit_VisualIndex:
            TUnitVisualIndex VisualIndices[ Size / sizeof( TUnitVisualIndex ) ];
            break;

        default:
            byte Data[ Size ];
    }
    
    FAlign( 16 );
} TTableSegment <read=TableSegmentToString>;

string TableSegmentToString( TTableSegment& segment )
{
    return EnumToString( segment.type );
}

typedef struct( string tableName, u32 endOffset )
{
    local int segmentIndex = 0;
    local TableSegmentType segmentType;

    while ( FTell() < endOffset )
    {
        segmentType = TableSegmentType_Unknown;
        if ( !Stricmp( tableName, "persona" ) )
        {
            switch ( segmentIndex )
            {
                case 0: segmentType = TableSegmentType_Persona_Stats; break;
                case 1: segmentType = TableSegmentType_Persona_SkillSets; break;
                case 2: segmentType = TableSegmentType_Persona_LevelUpThresholds; break;
                case 3: segmentType = TableSegmentType_Persona_PartyMembers; break;
            }
        }
        else if ( !Stricmp( tableName, "player" ) )
        {
            switch ( segmentIndex )
            {
                case 0: segmentType = TableSegmentType_Player_LevelUpThresholds;
            }
        } 
        else if ( !Stricmp( tableName, "elsai" ) )
        {
            switch ( segmentIndex )
            {
                case 0: segmentType = TableSegmentType_Elsai_Segment0; break;
                case 1: segmentType = TableSegmentType_Elsai_Segment1; break;
            }
        } 
        else if ( !Stricmp( tableName, "aicalc" ) )
        {
            switch ( segmentIndex )
            {
                case 0: segmentType = TableSegmentType_AICalc_Segment1; break;
                case 1: segmentType = TableSegmentType_AICalc_Segment2; break;
                case 2: segmentType = TableSegmentType_AICalc_Segment3; break;
                case 3: segmentType = TableSegmentType_AICalc_Segment4; break;
                case 4: segmentType = TableSegmentType_AICalc_Segment5; break;
                case 5: segmentType = TableSegmentType_AICalc_Segment6; break;
                case 6: segmentType = TableSegmentType_AICalc_Segment7; break;
            }
        } 
        else if ( !Stricmp( tableName, "encount" ) )
        {
            switch ( segmentIndex )
            {
                case 0: segmentType = TableSegmentType_Encounter; break;
            }
        }
        else if ( !Stricmp( tableName, "skill" ) )
        {
            switch ( segmentIndex )
            {
                case 0: segmentType = TableSegmentType_Skill_Elements; break;
                case 1: segmentType = TableSegmentType_Skill_ActiveSkillData; break;
            }
        }
        else if ( !Stricmp( tableName, "unit" ) )
        {
            switch ( segmentIndex )
            {
                case 0: segmentType = TableSegmentType_Unit_Stats; break;
                case 1: segmentType = TableSegmentType_Unit_Segment1; break;
                case 2: segmentType = TableSegmentType_Unit_ElementalAffinities; break;
                case 3: segmentType = TableSegmentType_Unit_Segment3; break;
                case 4: segmentType = TableSegmentType_Unit_VisualIndex; break;
            }
        }

        Printf( "%s\n", EnumToString( segmentType ) );
        SetBackColor( MyRandom( 0xFFFFFFFF ) );
        TTableSegment Segment( segmentType );

        ++segmentIndex;
    }

} TTable;

typedef struct
{
    LittleEndian();
    char FileName[ 252 ];
    u32 FileSize;

    if ( Stricmp( FileNameGetExtension( FileName ), ".tbl" ) == 0 )
    {
        BigEndian();
        TTable Table( FileNameGetBase( FileName, false ), FTell() + FileSize ); 
    }
    else
    {
        u8 Data[ FileSize ];
    }

    FAlign( 64 );  
} TFile <read=FileToString>; 

string FileToString( struct TFile& file )
{
    return file.FileName;
}


// Read table
local string filePath = GetFileName();
local string fileName = FileNameGetBase( filePath, false );
local string fileExt = FileNameGetExtension( filePath );

if ( Stricmp( fileExt, ".pac" ) == 0 )
{
    // table.pac
    while ( !FEof() )
    {
        TFile File;
    }
}
else if ( Stricmp( fileExt, ".tbl" ) == 0 )
{
    // tbl file
    BigEndian();
    TTable Table( fileName, FileSize() );
}